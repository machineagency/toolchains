const p=(t,n)=>_(t,n)<1e-6,_=([t,n],[o,e])=>Math.sqrt((o-t)**2+(e-n)**2),F=(t,n)=>Math.sqrt((n[0]-t[0])**2+(n[1]-t[1])**2),m=(t,n)=>{const o=F(t,n);return[(n[0]-t[0])/o,(n[1]-t[1])/o]},L=t=>{const n=Math.sqrt(t[0]**2+t[1]**2);return[t[0]/n,t[1]/n]};function M(t,n=[0,0],o=[0,0]){if(typeof t[0]!="string")return t;if(t[0]==="chamfer"){const[e,s,c]=t;return c}else if(t[0]==="fillet"){const[e,s,c]=t;return c}else if(t[0]==="cubic"){const[e,s,c,h]=t;return c}else if(t[0]==="relative"){const[e,s,c]=t;return[n[0]+s,n[1]+c]}else if(t[0]==="turnForward"){const[e,s,c]=t,h=s/180*Math.PI,r=H(n,o)+h;return[n[0]+Math.cos(r)*c,n[1]+Math.sin(r)*c]}else return null}function N(t){if(typeof t[0]!="string")return t;if(t[0]==="chamfer"){const[n,o,e]=t;return e}else if(t[0]==="fillet"){const[n,o,e]=t;return e}else if(t[0]==="cubic"){const[n,o,e,s]=t;return s}else return null}function k(t,n,o){const[e,s]=t,[c,h]=n,[r,i]=o,a=e-r,l=s-i,u=c-r,f=h-i,d=a*a+l*l,g=d+a*u+l*f,x=4/3*(Math.sqrt(2*d*g)-g)/(a*f-l*u),I=r+a-x*l,b=i+l+x*a,w=r+u+x*f,C=i+f-x*u;return[[e,s],[I,b],[w,C],[c,h]]}function v(t,n,o,e){if(p(n,t)||p(n,o)||p(t,o)||e<=0)return null;const s=m(n,t),c=m(n,o),h=Math.acos(s[0]*c[0]+s[1]*c[1]);let r=e/Math.tan(h/2);const i=_(t,n),a=_(o,n);r=Math.min(i,a,r),e=Math.min(r*Math.tan(h/2),e);const l=[n[0]+s[0]*r,n[1]+s[1]*r],u=[n[0]+c[0]*r,n[1]+c[1]*r],f=L([s[0]+c[0],s[1]+c[1]]),d=Math.sqrt(r**2+e**2),g=[n[0]+f[0]*d,n[1]+f[1]*d];return[l,u,g]}function H(t,n){const o=t[0]-n[0],e=t[1]-n[1];return Math.atan2(e,o)}function S(t){const n=[],o=[];if(t.length===0)return{cubics:n,filletsAndChamfers:o};let e=M(t[0]),s=N(t[0]);s===null&&(s=e);const c=()=>n.length>0?y(n.at(-1),32).slice(-2).reverse():[e,e];for(let h=1;h<t.length;h++){const r=t[h];if(typeof r[0]!="string")n.push([e,s,r,r]),e=r,s=r;else if(r[0]==="fillet"||r[0]==="chamfer"){const[i,a,l]=r,u=M(l,...c());n.push([e,s,u,u]),e=u,s=u;const f=h===t.length-1?u:M(t[h+1],u,e),d={lowerLimit:e,start:u,upperLimit:f,radius:a,cubicIndex:h-1,type:i};o.push(d)}else if(r[0]==="cubic"){const[i,a,l,u]=r;n.push([e,s,a,l]),e=l,s=u}else if(r[0]==="relative"||r[0]==="turnForward"){const i=M(r,...c());n.push([e,s,i,i]),e=i,s=i}else throw console.log(r),new Error("Unknown command used in path(...)")}return{cubics:n,filletsAndChamfers:o}}function T(t){const{cubics:n,filletsAndChamfers:o}=S(t);let e=[];const s=30,c=[];for(let r=0;r<n.length;r++){const i=n[r];r===0&&e.push(i[0]);const a=e.length-1;e.push(...y(i,s).slice(1));const l=u=>{u.cubicIndex===r&&r!==n.length-1&&(u.ptIndex=e.length-1,u.lowerIndex=a,u.upperIndex=u.ptIndex+y(n[r+1],s).length-1,c.push(u))};o.forEach(l)}let h=0;return c.forEach(r=>{if(r.radius<=0||r.upperIndex-r.lowerIndex>2)return;let i=-1,a=1;if(i=Math.max(i,r.lowerIndex-r.ptIndex),a=Math.min(a,r.upperIndex-r.ptIndex),i>=a)return;const l=r.ptIndex+h,u=e[l],f=e[l+i],d=e[l+a],g=v(f,u,d,r.radius);if(g){const[x,I,b]=g,w=l+i+1,C=l+a,q=r.type==="fillet"?y(k(x,I,b),s):[x,I];e=[...e.slice(0,w),...q,...e.slice(C)],h+=q.length-(a-i-1)}}),e}const A=(t,n,o)=>[(1-t)*n[0]+t*o[0],(1-t)*n[1]+t*o[1]],D=(t,n,o,...e)=>e.length>0?[A(t,n,o),...D(t,o,...e)]:[A(t,n,o)],E=(t,n)=>n.length>1?E(t,D(t,...n)):n[0];function y(t,n){if(p(t[0],t[1])&&p(t[2],t[3]))return[t[0],t[3]];const o=[];for(let e=0;e<=1*n;e+=1){const s=E(e/n,t);o.push(s)}return o}export{y as bezier,T as path,S as pathToCubics};
