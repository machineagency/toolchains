import{dataIndexFromString as M,dataIndicesSamePathCmd as k,cmdType as F,createListener as N}from"./utils-c498b33b.js";const A=(g,e)=>{const u=N(g);let s="",v=!1;u("pointerdown",".point",n=>{e.transforming=!0,n.target,s=n.target.dataset.index;let c=!1;e.keysPressed.includes("Shift")?e.selectedPts.has(s)?(e.selectedPts.delete(s),c=y(s,t=>{e.selectedPts.delete(t.join(","))})):e.selectedPts.add(s):e.selectedPts.has(s)||(e.selectedPts=new Set([s])),c||y(s,t=>{e.selectedPts.add(t.join(",")),e.selectedPts.size===2&&(v=!0)}),e.selectedPts.size===1&&(v=!0),e.dispatch()}),u("pointermove","",n=>{if(!e.transforming)return;const{x:c,y:t}=e.panZoom.svgPoint({x:n.offsetX,y:n.offsetY}),h=M(s).reduce((o,r)=>o[r],e.paths),i=c-h[0],d=t-h[1],m=o=>{const[r,f]=o.split(",");return Number(f)===0||Number(f)===e.paths[r].length-1},p=e.closedPaths.has(s.split(",")[0]);e.selectedPts.forEach(o=>{k(o,s)||p&&m(s)&&m(o)||(o.split(",")[0],b(M(o),i,d))}),X(M(s),c,t),y(s,o=>{b(o,i,d)}),e.dispatch()}),u("pointerup","",n=>{v&&!n.shiftKey&&(e.selectedPts=new Set),e.transforming=!1,v=!1,e.dispatch()});const y=(n,c)=>{const t=M(n);if(t.length===3&&[1,3].includes(t.at(-1)))return;if(!e.closedPaths.has(t[0]))return!1;const i=e.paths[t[0]],d=t[1]===0,m=t[1]===i.length-1;return d&&(t[1]=i.length-1,c(t)),m&&(t[1]=0,c(t)),e.dispatch(),!0};function b(n,c,t){let h=n.reduce((i,d)=>i[d],e.paths);h[0]+=c,h[1]+=t,e.dispatch()}function X(n,c,t){const i=e.paths[n[0]][n[1]];if(F(i)==="point"){const l=n.reduce((a,C)=>a[C],e.paths);l[0]=c,l[1]=t,e.dispatch();return}let[m,p,o,r]=Y(n);const f=n.at(-1),P={1:p,2:o,3:r}[f],S=[...P];P[0]=c,P[1]=t;const w=P[0]-S[0],z=P[1]-S[1];if(e.handleMovement!=="broken"&&[1,3].includes(f)){const l=o;let a={1:r,3:p}[f];const C=c-l[0],j=t-l[1],E=_([c,t],l);if(e.handleMovement==="symmetric")a[0]=l[0]-C,a[1]=l[1]-j;else if(e.handleMovement==="colinear"){const I=Math.sqrt((a[0]-l[0])**2+(a[1]-l[1])**2);a[0]=l[0]-I*Math.cos(E),a[1]=l[1]-I*Math.sin(E)}}f===2&&(p[0]+=w,p[1]+=z,r[0]+=w,r[1]+=z),e.dispatch()}function Y(n){let[c,t,h,i]=n.slice(0,-1).reduce((r,f)=>r[f],e.paths);const d=e.paths[n[0]],m=e.closedPaths.has(n[0]),p=d[0],o=d.at(-1);return m&&[0,d.length-1].includes(n[1])&&(t=o[1],i=p[3]),["cubic",t,h,i]}};function _(g,e){const u=g[0]-e[0],s=g[1]-e[1];return Math.atan2(s,u)}export{A as addPointInteraction};
