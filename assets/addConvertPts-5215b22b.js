import{dataIndexFromString as b,dataIndicesSamePathCmd as J,createListener as N}from"./utils-c498b33b.js";function k(n,e){const i=N(n),g=(a,l)=>{const t=b(a);if(t.length===3&&[1,3].includes(t.at(-1)))return;if(!e.closedPaths.has(t[0]))return!1;const h=e.paths[t[0]],c=t[1]===0,o=t[1]===h.length-1;return c&&(t[1]=h.length-1,l(t)),o&&(t[1]=0,l(t)),!0};i("dblclick",".point",a=>{const l=a.target.dataset.type,t=b(a.target.dataset.index),s=e.paths[t[0]];if(l==="point"||l==="cubic"&&t.at(-1)===2){e.selectedPts.forEach(o=>{J(a.target.dataset.index,o)&&(e.selectedPts.delete(o),g(a.target.dataset.index,r=>{e.selectedPts.delete(r)}))});const h=e.closedPaths.has(t[0]),c=t.reduce((o,r)=>o[r],e.paths);if(l==="cubic"&&(s[t[1]]=[...c],h&&(t[1]===0&&(s[s.length-1]=[...c]),t[1]===s.length-1&&(s[0]=[...c]))),l==="point"){const o=O(s,t[1]),r=2;let u=[c[0]-r*Math.cos(o),c[1]-r*Math.sin(o)],p=[c[0]+r*Math.cos(o),c[1]+r*Math.sin(o)];const P=[c[0]-r*Math.cos(o+Math.PI/2),c[1]-r*Math.sin(o+Math.PI/2)],y=(d,M,S)=>(M[0]-d[0])*(S[1]-d[1])-(M[1]-d[1])*(S[0]-d[0]),I=t[1]>=1?f(s,t[1]-1):f(s,t[1]);if(!(y(c,P,u)*y(c,P,I)>=0)){const d=u;u=p,p=d}const m=["cubic",u,[...c],p];s[t[1]]=m,h&&(t[1]===0&&(s[s.length-1]=JSON.parse(JSON.stringify(m))),t[1]===s.length-1&&(s[0]=JSON.parse(JSON.stringify(m))))}}e.dispatch()})}function O(n,e){if(n.length<=3)return 0;let i=e>=1?f(n,e-1):f(n,e),g=e<n.length-1?f(n,e+1):f(n,e);(e===0||e===n.length-1)&&(i=f(n,1),g=f(n,n.length-2));const a=f(n,e),l=C(a,i),t=C(g,a);return(l+t)/2}function A(n){return typeof n[0]=="number"?"point":n[0]}function f(n,e){const i=n[e];return A(i)==="point"?i:i[2]}function C(n,e){const i=n[0]-e[0],g=n[1]-e[1];return Math.atan2(g,i)}export{k as addConvertPts};
